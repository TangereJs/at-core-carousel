<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="swipe-import.html">

<dom-module id="at-core-carousel">
  <template>
    <style>
      .swipe {
        overflow: hidden;
        visibility: hidden;
        position: relative;
      }

      .swipe-wrap {
        overflow: hidden;
        position: relative;
      }

      .swipe-wrap > div {
        float: left;
        width: 300px;
        position: relative;
        overflow: hidden;
      }
    </style>
    <at-core-spinner id="spinner" type="wave"></at-core-spinner>
    <at-carbon-message id="msgEmptyList" type="info"></at-carbon-message>
    <div id="insertContainer" class="swipe">
      <div id="insertPoint" class="swipe-wrap">

      </div>
    </div>
  </template>
  <script>
    'use strict';
    Polymer({
      is: 'at-core-carousel',
      properties: {
        items: {
          type: Array,
          value: function() {
            return [];
          }
        },
        itemComponent: {
          type: String,
          value: "",
          notify: true
        },
        cardWidth: {
          type: Number,
          value: 320,
          notify: true
        },
        layout: {
          type: String,
          value: "card",
          notify: true
        },
        indicator: {
          type: Boolean,
          value: false,
          reflectToAttribute: true,
          observer: "changeIndicator"
        },
        emptyList: {
          type: String,
          value: "No data found"
        },
        _initialize: {
          type: String,
          value: "",
          notify: true
        }
      },

      observers: [
        'initialize(items.*,itemComponent, layout, cardWidth, emptyList)'
      ],

      changeIndicator: function() {
        this.$.spinner.display = this.indicator ? "block" : "none";
        if (this.indicator) {
          this.clear();
        }
      },

      clear: function() {

        this.$.msgEmptyList.html = ""; // clear error message

        // remove all items
        var listWrapper = Polymer.dom(this.root).querySelector("#listWrapper");
        if (listWrapper) {
          while (listWrapper.hasChildNodes()) {
            listWrapper.removeChild(listWrapper.lastChild);
          }
        }
        Polymer.dom.flush();
      },

      layoutList: function() {

        var layout = this.layout == "grid" ? "grid" : "card";

        // get the container width
        //var wrapper = this.shadowRoot.getElementById("listWrapper");
        var wrapper = Polymer.dom(this.root).querySelector("#listWrapper");
        if (!wrapper) return; // component not yet ready

        var cw = wrapper.offsetWidth;

        // retry if offsetWidth == 0 to give time to paint
        if (cw == 0) {
          this.async(function() {
            this.layoutList();
          }, 100);
          return;
        }

        // number of columns 1...5
        var cols = Math.floor(cw / this.cardWidth);
        if (cols < 1) cols = 1;
        if (cols > 5) cols = 5;

        //console.log("cols " + cols + " cw " + cw + " " + this.cardWidth);

        var newClass = layout + " cols-" + cols;
        if (wrapper.className != newClass) {
          wrapper.className = newClass;
        }

        return cw;
      },

      initialize: function() {

        var mel = this.$.msgEmptyList;
        mel.html = "";

        // show error if items is an empty array
        if (this.items.constructor == Array && this.items.length == 0) {
          mel.html = this.emptyList;
        }

        if (!this.items || (!this.template && !this.itemComponent)) {
          return;
        }

        if (!!this.itemComponent) {

          // dynamically load item-component

          // load item-component from other component (itemComponent = component-name/item-component) or from localfolder (item-component)
          var compUrl = document.baseURI.toLowerCase().indexOf("/components/") >= 0 ? "../" : "components/";
          if (document.URL.indexOf("/elements/designer-element/") >= 0) compUrl = "/components/"; // standalone designer preview?

          if (window.ComponentsBase != undefined) compUrl = window.ComponentsBase;

          var compName = this.itemComponent;
          var importPath = compName.indexOf("/") >= 0 ? compUrl + compName + ".html" : compName + ".html";

          this.importHref(importPath, function() {
            this.bindItems();
          }, function() {
            Polymer.signal("busy-end");
            alert(window.location.href + "\n\nERROR: failed to load list item " + this.itemComponent);
            location.hash = ""; // clear current hash
            location.reload(); // go to start app by reloading without hash
          });


        } else {
          // with inline template binding can happen immediately
          this.bindItems();
        }
      },

      bindItems: function() {

        if (!this.items || (!this.template && !this.itemComponent)) {
          return;
        }

        // listWrapper is used to get the available width
        //var listWrapper = this.shadowRoot.getElementById("listWrapper");
        var listWrapper = this.$.insertContainer; //Polymer.dom(this.root).querySelector("#listWrapper");

        if (!listWrapper) {
          // create new listWrapper
          listWrapper = document.createElement("div");
          listWrapper.id = "listWrapper";
          //this.shadowRoot.appendChild(listWrapper);
          Polymer.dom(this.root).appendChild(listWrapper);
        } else {
          // empty existing wrapper
          while (listWrapper.hasChildNodes()) {
            listWrapper.removeChild(listWrapper.lastChild);
          }
        }

        Polymer.dom.flush();

        // calculate layout columns
        if (0 == this.layoutList()) {

          // 0 == parent width not yet availble, retry
          this.async(function() {
            this.layoutList();
          });
        }

        // create list container
        var fragment = document.createDocumentFragment();

        var comp = this.itemComponent;
        if (comp.indexOf("/") > 0) {
          comp = comp.substring(1 + comp.indexOf("/"));
        }

        // create list container
        var listContainer = this.$.insertPoint; //document.createElement("div");
        listContainer.classList.add("listContainer");

        // create wrapper div
        var listItem = document.createElement("div");
        listItem.className = "listItem";


        // apply template for each item in items
        //  ... wrap result with card layout div
        //  ... and add to listContainer

        var item = null;

        // create component element
        var comp = this.itemComponent;
        if (comp.indexOf("/") > 0) {
          comp = comp.substring(1 + comp.indexOf("/"));
        }

        for (var i = 0; i < this.items.length; i++) {

          var item = document.createElement(comp);
          item.item = this.items[i];

          var div = listItem.cloneNode(true);
          div.appendChild(item);

          //listContainer.appendChild(div);
          Polymer.dom(listContainer).appendChild(div);
          this._container = Polymer.dom(listContainer);
        }

        // transform ShadyDom styles of innerHTML
        if (!Polymer.Settings.useShadow) Polymer.StyleTransformer.dom(listWrapper, this.is, true);

        this.indicator = false; // hide indicator before list is rendered

        //append list container to shadow dom
        Polymer.dom(listWrapper).appendChild(listContainer);

        var swipeInstance = new Swipe(listWrapper, {
          draggable: true
        });

        this.fire("list-ready");
      },

      ready: function() {
        // update layout after windows resize
        window.addEventListener('resize', function() {

          this.layoutList();

          // 2nd layout after side drawer animation is finished
          setTimeout(function() {
            this.layoutList();
          }.bind(this), 500);

        }.bind(this), true);

        // update layout after orientation change
        window.addEventListener('orientationchange', function() {
          this.async(function() {
            this.layoutList();
          });

          // 2nd try to ensure that even slow android devices show the correct result
          setTimeout(function() {
            this.layoutList();
          }.bind(this), 1000);
        }.bind(this), false);

        // show/hide drawer changes also the available width
        window.addEventListener('core-responsive-change', function() {

          this.async(function() {
            this.layoutList();
          });

          // 2nd layout after side drawer animation is finished
          setTimeout(function() {
            this.layoutList();
          }.bind(this), 500);

        }.bind(this), false);
      }
    });
  </script>
</dom-module>
