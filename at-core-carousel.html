<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="swipe-import.html">

<dom-module id="at-core-carousel">
  <template>
    <style include="at-form-common"></style>
    <style>
      .swipe {
        overflow: hidden;
        visibility: hidden;
        position: relative;
      }

      .swipe-wrap {
        overflow: hidden;
        position: relative;
      }

      .swipe-wrap > div {
        float: left;
        width: 100%;
        position: relative;
        overflow: hidden;
      }

      .listItem {
        border: 2px dotted black;
      }

      /*
       * styles for horizontal scrollable single row carousel when cards have fixed width
       */
      .hide-scrollbar-in-chrome ::-webkit-scrollbar {
        display: none;
      }

      .carousel {
        display: block;
        overflow-x: auto;
        position: relative;
        white-space: nowrap;
        transform: translate3d(0,0,0);
      }

      .carousel-wrap {
        display: inline-block;
      }

      .carousel-item {
        display: inline-block;
        width: 300px;
        white-space: normal;
      }

    </style>
    <at-core-spinner id="spinner" type="wave"></at-core-spinner>
    <at-carbon-message id="msgEmptyList" type="info"></at-carbon-message>
    <div id="insertContainer" class="swipe">
      <div id="insertPoint" class="swipe-wrap">
      </div>
    </div>

    <div id="staticItems" class="hidden">
      <content select="*"></content>
    </div>

  </template>
  <script>
    'use strict';
    Polymer({
      is: 'at-core-carousel',
      properties: {
        items: {
          type: Array,
          value: function() {
            return [];
          }
        },
        itemComponent: {
          type: String,
          value: "",
          notify: true
        },
        cardWidth: {
          type: Number,
          value: 320,
          notify: true
        },
        mode: {
          type: String,
          value: "static",
          xvaluelist: ['static', 'bound']
        },
        // layout: {
        //   type: String,
        //   value: "card",
        //   notify: true
        // },
        indicator: {
          type: Boolean,
          value: false,
          reflectToAttribute: true,
          observer: "changeIndicator"
        },
        emptyList: {
          type: String,
          value: "No data found"
        },
        _initialize: {
          type: String,
          value: "",
          notify: true
        }
      },

      observers: [
        'initialize(items.*,itemComponent, layout, cardWidth, emptyList)'
      ],

      changeIndicator: function() {
        this.$.spinner.display = this.indicator ? "block" : "none";
        if (this.indicator) {
          this.clear();
        }
      },

      clear: function() {

        this.$.msgEmptyList.html = ""; // clear error message

        // remove all items
        var insertPoint = Polymer.dom(this.$.insertPoint);
        while(insertPoint.firstChild) {
          insertPoint.removeChild(insertPoint.firstChild);
        }
        Polymer.dom.flush();
      },

      // layoutList: function() {
      //   return;
      //   var layout = this.layout == "grid" ? "grid" : "card";
      //
      //   // get the container width
      //   //var wrapper = this.shadowRoot.getElementById("listWrapper");
      //   var wrapper = Polymer.dom(this.root).querySelector("#listWrapper");
      //   if (!wrapper) return; // component not yet ready
      //
      //   var cw = wrapper.offsetWidth;
      //
      //   // retry if offsetWidth == 0 to give time to paint
      //   if (cw == 0) {
      //     this.async(function() {
      //       this.layoutList();
      //     }, 100);
      //     return;
      //   }
      //
      //   // number of columns 1...5
      //   var cols = Math.floor(cw / this.cardWidth);
      //   if (cols < 1) cols = 1;
      //   if (cols > 5) cols = 5;
      //
      //   //console.log("cols " + cols + " cw " + cw + " " + this.cardWidth);
      //
      //   var newClass = layout + " cols-" + cols;
      //   if (wrapper.className != newClass) {
      //     wrapper.className = newClass;
      //   }
      //
      //   return cw;
      // },

      initialize: function() {

        var mel = this.$.msgEmptyList;
        mel.html = "";

        // remove css classes from insertContainer and insertPoint
        var insertContainer = Polymer.dom(this.$.insertContainer);
        insertContainer.classList.remove('swipe');
        insertContainer.classList.remove('carousel');
        var insertPoint = Polymer.dom(this.$.insertPoint);
        insertPoint.classList.remove('swipe-wrap');
        insertPoint.classList.remove('carousel-wrap');

        // its up to martin to decide what is the relationship between mode
        // and isFixed width
        // mode basically tells what is the data source static/bound; also both sources can be combined although that is a non trivial problem
        // cardWidth in essence determines the rendering mode
        var mode = this.mode;
        if (mode === "bound") {
          // add swipe classes to the insertContainer and insertPoint
          insertContainer.classList.add('swipe');
          insertPoint.classList.add('swipe-wrap');

          this._initializeBoundDataSource();
        } else if (mode === "static") {
          // add carousel classes to the insertContainer and insertPoint
          insertContainer.classList.add('carousel');
          insertPoint.classList.add('carousel-wrap');

          this._initializeStaticDataSource();
        } else {
          // invalid mode specified
          // TODO: localize
          Polymer.dom(mel).innerHTML = "Mode " + mode + " is invalid.";
        }

        var isFixedWidth = this._isNumber(this.cardWidth);

        if (isFixedWidth) {
          // render mode is carousel
        } else {
          // render mode is swipe
        }

        // show error if items is an empty array
        if (this.items.constructor == Array && this.items.length == 0) {
          mel.html = this.emptyList;
        }

        if (this.mode === "static") {
          // initialize swipe instace from light children
          //append list container to shadow dom
          // var listWrapper = this.$.insertContainer;
          // var swipeInstance = new Swipe(listWrapper, {
          //   draggable: true,
          //   useFixedWidth: this._isNumber(this.cardWidth)
          // });
        } else if (this.mode === "bound") {
          if (!this.items || (!this.template && !this.itemComponent)) {
            return;
          }
        }

        if (!!this.itemComponent) {

          // dynamically load item-component

          // load item-component from other component (itemComponent = component-name/item-component) or from localfolder (item-component)
          var compUrl = document.baseURI.toLowerCase().indexOf("/components/") >= 0 ? "../" : "components/";
          if (document.URL.indexOf("/elements/designer-element/") >= 0) compUrl = "/components/"; // standalone designer preview?

          if (window.ComponentsBase != undefined) compUrl = window.ComponentsBase;

          var compName = this.itemComponent;
          var importPath = compName.indexOf("/") >= 0 ? compUrl + compName + ".html" : compName + ".html";

          this.importHref(importPath, function() {
            this._initializeBoundDataSource();
          }, function() {
            Polymer.signal("busy-end");
            alert(window.location.href + "\n\nERROR: failed to load list item " + this.itemComponent);
            location.hash = ""; // clear current hash
            location.reload(); // go to start app by reloading without hash
          });


        } else {
          // with inline template binding can happen immediately
          this._initializeBoundDataSource();
        }
      },

      _initializeBoundDataSource: function() {

        if (!this.items || (!this.template && !this.itemComponent)) {
          return;
        }

        // listWrapper is used to get the available width
        //var listWrapper = this.shadowRoot.getElementById("listWrapper");
        var listWrapper = this.$.insertContainer; //Polymer.dom(this.root).querySelector("#listWrapper");

        if (!listWrapper) {
          // create new listWrapper
          listWrapper = document.createElement("div");
          listWrapper.id = "listWrapper";
          //this.shadowRoot.appendChild(listWrapper);
          Polymer.dom(this.root).appendChild(listWrapper);
        } else {
          // empty existing wrapper
          while (listWrapper.hasChildNodes()) {
            listWrapper.removeChild(listWrapper.lastChild);
          }
        }

        Polymer.dom.flush();

        var comp = this.itemComponent;
        if (comp.indexOf("/") > 0) {
          comp = comp.substring(1 + comp.indexOf("/"));
        }

        // create list container
        var listContainer = this.$.insertPoint; //document.createElement("div");
        listContainer.classList.add("listContainer");

        // create wrapper div
        var listItem = document.createElement("div");
        listItem.className = "listItem";


        // apply template for each item in items
        //  ... wrap result with card layout div
        //  ... and add to listContainer

        var item = null;

        // create component element
        var comp = this.itemComponent;
        if (comp.indexOf("/") > 0) {
          comp = comp.substring(1 + comp.indexOf("/"));
        }

        for (var i = 0; i < this.items.length; i++) {

          var item = document.createElement(comp);
          item.item = this.items[i];

          var div = listItem.cloneNode(true);
          div.appendChild(item);

          //listContainer.appendChild(div);
          Polymer.dom(listContainer).appendChild(div);
          this._container = Polymer.dom(listContainer);
        }

        // transform ShadyDom styles of innerHTML
        if (!Polymer.Settings.useShadow) Polymer.StyleTransformer.dom(listWrapper, this.is, true);

        this.indicator = false; // hide indicator before list is rendered

        Polymer.dom.flush();

        //append list container to shadow dom
        Polymer.dom(listWrapper).appendChild(listContainer);
        if (this.swipeInstance) {
          this.swipeInstance.kill();
        }
        var swipeInstance = this.swipeInstance = new Swipe(listWrapper, {
          draggable: true,
          useFixedWidth: this._isNumber(this.cardWidth)
        });

        this.fire("list-ready");
      },

      _initializeStaticDataSource: function () {
        var staticItems = Polymer.dom(this.$.staticItems);
        var insertPoint = Polymer.dom(this.$.insertPoint);

        var children = staticItems.getEffectiveChildNodes();
        var child;
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          child.parentElement.removeChild(child);
          if (child.nodeType !== 3) {
            child.classList.add('carousel-item');
            insertPoint.appendChild(child);
          }
        }

        Polymer.dom.flush();
      },

      _isNumber: function (obj) {
        return Object.prototype.toString.call(obj) === "[object Number]";
      },

      ready: function() {
        // update layout after windows resize
        // window.addEventListener('resize', function() {
        //
        //   this.layoutList();
        //
        //   // 2nd layout after side drawer animation is finished
        //   setTimeout(function() {
        //     this.layoutList();
        //   }.bind(this), 500);
        //
        // }.bind(this), true);
        //
        // // update layout after orientation change
        // window.addEventListener('orientationchange', function() {
        //   this.async(function() {
        //     this.layoutList();
        //   });
        //
        //   // 2nd try to ensure that even slow android devices show the correct result
        //   setTimeout(function() {
        //     this.layoutList();
        //   }.bind(this), 1000);
        // }.bind(this), false);
        //
        // // show/hide drawer changes also the available width
        // window.addEventListener('core-responsive-change', function() {
        //
        //   this.async(function() {
        //     this.layoutList();
        //   });
        //
        //   // 2nd layout after side drawer animation is finished
        //   setTimeout(function() {
        //     this.layoutList();
        //   }.bind(this), 500);
        //
        // }.bind(this), false);
        //
        // var self = this;
        // self.async(function(){
        //   self.initialize();
        // });
      }
    });
  </script>
</dom-module>
