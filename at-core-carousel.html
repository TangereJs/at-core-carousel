<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="swipe-import.html">

<dom-module id="at-core-carousel">
  <template>
    <style include="at-form-common"></style>
    <style>
      :host {
        display: block;
        box-sizing: border-box;
      }

      .swipe {
        overflow: hidden;
        visibility: hidden;
        position: relative;
      }

      .swipe-wrap {
        overflow: hidden;
        position: relative;
      }

      .swipe-wrap > div {
        float: left;
        width: 100%;
        position: relative;
        overflow: hidden;
        box-sizing: border-box;
      }

      .swipe-item { }

      /*
       * styles for horizontal scrollable single row carousel when cards have fixed width
       */
      .hide-scrollbar-in-chrome ::-webkit-scrollbar {
        display: none;
      }

      .carousel {
        display: block;
        overflow-x: auto;
        position: relative;
        white-space: nowrap;
        transform: translate3d(0,0,0);
      }

      .carousel-wrap {
        display: inline-block;
      }

      .carousel-item {
        display: inline-block;
        width: 300px;
        white-space: normal;
      }

    </style>
    <at-core-spinner id="spinner" type="wave"></at-core-spinner>
    <at-carbon-message id="msgEmptyList" type="info"></at-carbon-message>
    <div id="insertContainer" class="swipe">
      <div id="insertPoint" class="swipe-wrap">
      </div>
    </div>

    <div id="staticItems" class="hidden">
      <content id="contentInsertPoint" select="*"></content>
    </div>

  </template>
  <script>
    'use strict';
    Polymer({
      is: 'at-core-carousel',
      behaviors: [ Tangere.behaviors.i18n ],
      properties: {
        items: {
          type: Array,
          value: function() {
            return [];
          }
        },
        itemComponent: {
          type: String,
          value: "",
          notify: true
        },
        cardWidth: {
          type: Number,
          value: 320,
          notify: true
        },
        mode: {
          type: String,
          value: "static",
          xvaluelist: ['static', 'bound']
        },
        indicator: {
          type: Boolean,
          value: false,
          reflectToAttribute: true,
          observer: "changeIndicator"
        },
        emptyList: {
          type: String,
          value: "No data found"
        }
      },

      observers: [
        'initialize(items.*, itemComponent, cardWidth, emptyList)'
      ],

      changeIndicator: function() {
        this.$.spinner.display = this.indicator ? "block" : "none";
        if (this.indicator) {
          this.clear();
        }
      },

      clear: function() {

        this.$.msgEmptyList.html = ""; // clear error message

        // remove all items
        var insertPoint = Polymer.dom(this.$.insertPoint);
        while(insertPoint.firstChild) {
          insertPoint.removeChild(insertPoint.firstChild);
        }
        Polymer.dom.flush();
      },

      initialize: function() {
        if (!this.isAttached) {
          return ;
        }

        // clear previous error message
        var mel = this.$.msgEmptyList;
        mel.html = "";

        // remove css classes from insertContainer and insertPoint
        var insertContainer = Polymer.dom(this.$.insertContainer);
        insertContainer.classList.remove('swipe');
        insertContainer.classList.remove('carousel');
        var insertPoint = Polymer.dom(this.$.insertPoint);
        insertPoint.classList.remove('swipe-wrap');
        insertPoint.classList.remove('carousel-wrap');

        var renderMode = this._getRenderMode();
        if (renderMode === "carousel") {
          // render mode is carousel; add carousel classes to the insertContainer and insertPoint
          insertContainer.classList.add('carousel');
          insertPoint.classList.add('carousel-wrap');
        } else {
          // render mode is swipe; add swipe classes to the insertContainer and insertPoint
          insertContainer.classList.add('swipe');
          insertPoint.classList.add('swipe-wrap');
          renderMode = "swipe";
        }

        // check mode and initialize correct data source
        var mode = this.mode;
        if (mode === "bound") {
          this._initializeBoundDataSource(renderMode);
        } else if (mode === "static") {
          this._initializeStaticDataSource(renderMode);
        } else {
          // invalid mode specified
          // TODO: localize
          Polymer.dom(mel).innerHTML = this.T("Mode {0} is invalid.", mode);
        }

      },

      _initializeBoundDataSource: function(renderMode) {
        var errorCarbonMsg = this.$.msgEmptyList;

        var items = this.items;
        var itemComponent = this.itemComponent;

        // validate input parameters
        if (!items) {
          // if items is null or undefined
          errorCarbonMsg.html = this.T("Data for items not provided.");
          return;
        }

        if (!itemComponent) {
          errorCarbonMsg.html = this.T("Element name for data rendering not provided.");
          return;
        }

        if (!renderMode) {
          errorCarbonMsg.html = this.T("Rendering mode not specified.");
          return;
        }

        // show error if items is an empty array
        if (this._isArray(items) && items.length === 0) {
          errorCarbonMsg.html = this.emptyList;
          return;
        }

        // clear previously displayed elements
        this.clear();

        // display the available data

        if (!!this.itemComponent) {

          // dynamically load item-component

          // load item-component from other component (itemComponent = component-name/item-component) or from localfolder (item-component)
          var compUrl = document.baseURI.toLowerCase().indexOf("/components/") >= 0 ? "../" : "components/";
          if (document.URL.indexOf("/elements/designer-element/") >= 0) compUrl = "/components/"; // standalone designer preview?

          if (window.ComponentsBase != undefined) compUrl = window.ComponentsBase;

          var compName = this.itemComponent;
          var importPath = compName.indexOf("/") >= 0 ? compUrl + compName + ".html" : compName + ".html";

          this.importHref(importPath, function () {
            this._bindItems(renderMode);
          }, function () {
            Polymer.signal("busy-end");
            alert(window.location.href + "\n\nERROR: failed to load list item " + this.itemComponent);
            location.hash = ""; // clear current hash
            location.reload(); // go to start app by reloading without hash
          });
        } else {
          // with inline template binding can happen immediately
          this._bindItems(renderMode);
        }
      },

      _bindItems: function (renderMode) {
        // get correct renderElementName
        var renderElementName = this.itemComponent;
        if (renderElementName.indexOf("/") > 0) {
          renderElementName = renderElementName.substring(1 + renderElementName.indexOf("/"));
        }

        // create swipe item prototype for cloning
        var swipeItemPrototype = document.createElement("div");
        if (renderMode === "carousel") {
          Polymer.dom(swipeItemPrototype).classList.add("carousel-item");
          swipeItemPrototype.style.width = this.cardWidth + 'px';
        } else if (renderMode === "swipe") {
          Polymer.dom(swipeItemPrototype).classList.add("swipe-item");
        }

        // create render element prototype for cloning
        var renderElementPrototype = document.createElement(renderElementName);

        // get a reference to the insert point
        var insertPoint = this.$.insertPoint;

        // iterate through data, clone swipe/render elements and append to insert point
        for (var i = 0; i < this.items.length; i++) {
          var renderItemData = this.items[i];

          var swipeItem = swipeItemPrototype.cloneNode(true);
          var renderElement = document.createElement(renderElementName);
          renderElement.item = renderItemData;

          Polymer.dom(swipeItem).appendChild(renderElement);
          Polymer.dom(insertPoint).appendChild(swipeItem);
        }

        var insertContainer = this.$.insertContainer;
        // transform ShadyDom styles of innerHTML
        if (!Polymer.Settings.useShadow) {
          Polymer.StyleTransformer.dom(insertContainer, this.is, true);
        }

        this.indicator = false; // hide indicator before list is rendered

        Polymer.dom.flush();

        if (this.swipeInstance) {
          this.swipeInstance.kill();
        }
        if (renderMode === "swipe") {
          var swipeInstance = this.swipeInstance = new Swipe(insertContainer, {
            draggable: true
          });
        }

        this.fire("list-ready");
      },

      _initializeStaticDataSource: function (renderMode) {
        var staticItems = Polymer.dom(this.$.staticItems);
        var insertPoint = Polymer.dom(this.$.insertPoint);

        var children = this.getContentChildren('#contentInsertPoint');
        var child;
        var className = renderMode === "carousel" ? "carousel-item" : "swipe-item";
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          child.parentElement.removeChild(child);
          if (child.nodeType !== 3) {
            if (renderMode === "carousel") {
              child.style.width = this.cardWidth + 'px';
            }
            child.classList.add(className);
            insertPoint.appendChild(child);
          }
        }

        Polymer.dom.flush();
        var insertContainer = this.$.insertContainer;

        if (this.swipeInstance) {
          this.swipeInstance.kill();
        }

        if (renderMode === "swipe") {
          var self = this;
          this.async(function () {
            var swipeInstance = self.swipeInstance = new Swipe(insertContainer, {
              draggable: true
            });
          });
        }

      },

      _getRenderMode: function () {
        // we have cardWidth in attributes and property
        var cardWidthAttrValue = this.getAttribute('card-width');
        var cardWidthPropValue = this.cardWidth;

        var result;
        if (cardWidthAttrValue && cardWidthAttrValue.indexOf('%') !== -1 && isNaN(cardWidthPropValue)) {
          result = "swipe";
        } else if (cardWidthAttrValue === "" && cardWidthPropValue === 0) {
          result = "swipe";
        } else {
          result = "carousel";
        }

        return result;
      },

      _isArray: function (obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      },

      attached: function() {
        this.isAttached = true;
        this.initialize();
      }
    });
  </script>
</dom-module>
